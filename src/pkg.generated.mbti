// Generated using `moon info`, DON'T EDIT IT
package "mizchi/llm"

import {
  "mizchi/llm/tools",
}

// Values
pub fn collect(&Provider, Array[Message], tools? : Array[@tools.ToolDef]) -> CollectResult

pub fn collect_text(&Provider, Array[Message], tools? : Array[@tools.ToolDef]) -> String

pub let default_anthropic_model : String

pub let default_ollama_model : String

pub let default_openai_model : String

pub let default_openrouter_model : String

pub fn json_get_array(Json, String) -> Array[Json]?

pub fn json_get_int(Json, String) -> Int?

pub fn json_get_object(Json, String) -> Json?

pub fn json_get_string(Json, String) -> String?

pub fn parse_skill_frontmatter(String) -> (Map[String, String]?, String)

pub fn run_agent(BoxedProvider, @tools.ToolRegistry, Array[Message], StopCondition, (AgentEvent) -> Unit) -> Unit

pub fn run_agent_cancellable(BoxedProvider, @tools.ToolRegistry, Array[Message], StopCondition, () -> Bool, (AgentEvent) -> Unit) -> Unit

pub fn run_json_chat_loop(Array[Json], Array[Json], Int, (Array[Json], Array[Json]) -> JsonChatResponse, (String, Json) -> String, fallback_content? : String) -> JsonChatLoopResult

pub fn skill_metadata_description(Map[String, String]?, String) -> String

pub fn skill_metadata_is_always(Map[String, String]?, scope_key? : String) -> Bool

pub fn skill_metadata_is_available(Map[String, String]?, bins? : Map[String, Bool], env? : Map[String, String], scope_key? : String) -> Bool

pub fn skill_metadata_missing_requirements(Map[String, String]?, bins? : Map[String, Bool], env? : Map[String, String], scope_key? : String) -> String

pub fn strip_skill_frontmatter(String) -> String

pub fn truncate_messages(Array[Message], Int) -> Array[Message]

pub fn validate_tool_input(Json, Json) -> Array[String]

// Errors

// Types and methods
pub(all) enum AgentEvent {
  Stream(StreamEvent)
  ToolExecute(name~ : String, input~ : Json)
  ToolResult(name~ : String, result~ : String, is_error~ : Bool)
  StepComplete(step~ : Int)
  Done(reason~ : String)
}

pub struct BoxedProvider {
  inner : &Provider
}
pub fn BoxedProvider::name(Self) -> String
pub fn BoxedProvider::new(&Provider) -> Self
pub fn BoxedProvider::stream(Self, Array[Message], Array[@tools.ToolDef], StreamHandler) -> Unit

pub(all) struct CollectResult {
  text : String
  tool_calls : Array[ToolCall]
  finish_reason : FinishReason
  usage : Usage?
}

pub(all) enum ContentBlock {
  Text(String)
  ToolUse(id~ : String, name~ : String, input~ : Json)
  ToolResult(tool_use_id~ : String, content~ : String, is_error~ : Bool)
}
pub fn ContentBlock::to_anthropic_json(Self) -> Json
pub fn ContentBlock::to_openai_json(Self) -> Json

pub(all) enum FinishReason {
  Stop
  ToolUse
  Length
  ContentFilter
  Error
  Unknown(String)
}
pub fn FinishReason::from_string(String) -> Self
pub impl Show for FinishReason

pub(all) struct JsonChatLoopResult {
  final_content : String
  messages : Array[Json]
  iterations : Int
}

pub(all) struct JsonChatResponse {
  content : String
  tool_calls : Array[JsonChatToolCall]
  reasoning_content : String?
}
pub fn JsonChatResponse::new(String, Array[JsonChatToolCall], String?) -> Self

pub(all) struct JsonChatToolCall {
  id : String
  name : String
  arguments : Json
}
pub fn JsonChatToolCall::new(String, String, Json) -> Self

pub(all) struct Message {
  role : Role
  content : Array[ContentBlock]
}
pub fn Message::assistant(String) -> Self
pub fn Message::estimate_tokens(Self) -> Int
pub fn Message::get_text(Self) -> String
pub fn Message::system(String) -> Self
pub fn Message::text(Role, String) -> Self
pub fn Message::to_anthropic_json(Self) -> Json
pub fn Message::to_openai_json(Self) -> Json
pub fn Message::user(String) -> Self

pub struct MockProvider {
  responses : Array[Array[StreamEvent]]
  mut call_count : Int
}
pub fn MockProvider::boxed(Self) -> BoxedProvider
pub fn MockProvider::new(Array[Array[StreamEvent]]) -> Self

pub(all) struct ProviderConfig {
  api_key : String
  model : String
  max_tokens : Int
  system_prompt : String
  base_url : String
  timeout_sec : Int
  max_retries : Int
  retry_delay_ms : Int
}
pub fn ProviderConfig::new(String, String, String, max_tokens? : Int, system_prompt? : String, timeout_sec? : Int, max_retries? : Int, retry_delay_ms? : Int) -> Self

pub(all) enum Role {
  User
  Assistant
  System
  Tool
}
pub fn Role::from_string(String) -> Self
pub fn Role::to_string(Self) -> String
pub impl Eq for Role
pub impl Show for Role

pub(all) struct SkillEntry {
  name : String
  path : String
  source : String
  content : String
}
pub fn SkillEntry::new(String, String, String, String) -> Self

pub(all) struct SkillInfo {
  name : String
  path : String
  source : String
  available : Bool
}
pub fn SkillInfo::new(String, String, String, Bool) -> Self

pub(all) enum StopCondition {
  MaxSteps(Int)
  OnFinish
}

pub(all) enum StreamEvent {
  TextDelta(String)
  ToolCallStart(id~ : String, name~ : String)
  ToolCallDelta(id~ : String, input_delta~ : String)
  ToolCallEnd(id~ : String, name~ : String, input~ : Json)
  MessageStart
  MessageEnd(finish_reason~ : FinishReason, usage~ : Usage?)
  Error(String)
}
pub impl Show for StreamEvent

pub(all) struct StreamHandler {
  on_event : (StreamEvent) -> Unit
}

pub(all) struct ToolCall {
  id : String
  name : String
  input : Json
}

pub(all) struct Usage {
  input_tokens : Int
  output_tokens : Int
}
pub impl Show for Usage

// Type aliases
pub using @tools {type SchemaBuilder}

pub using @tools {type ToolChoice}

pub using @tools {type ToolDef}

pub using @tools {type ToolRegistry}

// Traits
pub(open) trait Provider {
  stream(Self, Array[Message], Array[@tools.ToolDef], StreamHandler) -> Unit
  name(Self) -> String
}

